package me.mode;

import java.awt.Robot;
import java.awt.event.InputEvent;

/*
 * ***********************************************************************面向对象思想设计原则****************************************************************************
 * 单一职责原则
 * 开闭原则
 * 里氏替换原则
 * 依赖注入原则
 * 接口分离原则
 * 迪米特原则
 * --------------------------------------------------------------------------------------------------------------
 * A.单一职责原则:
 * 核心思想：一个类只有一个职责
 * 其实就是为了“高内聚，低耦合”，也就是说，每个类应该只有一个职责，对外只能提供一种功能，而引起类的变化原因应该只有一个。在设计模式中，所有设计模式中
 * 所有的设计模式都遵循这一规则---------------“高内聚，低耦合”。
 * B.开闭原则：
 * 核心思想：一个对象对扩展开放，对修改关闭
 * 其实开放封闭原则的意思就是，对类的改动是通过增加代码进行的，而不是修改现有代码，如何做这一点，需要用到多态和抽象。
 * C.里氏替换原则：
 * 核心思想：在任何父类出现的地方都可以用它的子类来替代
 * 其实就是说，同一个继承体系中的对象应该有共同的行为特征。
 * D.依赖注入原则：
 * 核心思想：要依赖于抽象，不要依赖于具体实现。
 * 其实就是说：在应用程序中，所有类如果使用或依赖于其他的类，则这些其他类是抽象类，而不是具体的类，为了实现这个原则，我们编程时使用抽象类或者面向接口编程
 * 而不是针对具体 实现编程
 * E.接口分离原则：
 * 核心思想：不应该强迫程序依赖他们不需要使用的方法。
 * 其实就是说：一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口中。
 * F.迪米特原则：
 * 核心思想：一个对象应当对其他对象尽可能少的了解
 * 其实就是说：降低各个对象之间的耦合，提高系统的可维护性，再模块之间通过接口编程，而不理会模块的内部构造，使得耦合性降到最低
 */
/*
 * ***********************************************************************设计模式**********************************************************************************
 * 设计模式概述：设计模式是一套被反复使用，多数人知晓，经过分类编目的，代码设计经验的总结，使用设计模式是为了可重用代码，让代码更容易被他人理解，保证代码安全性
 * 设计模式不是一种方法和技术，而是一种思想，不针对编程语言，尽可能的面向接口编程，低耦合高内聚，使设计的程序可以服用。
 * 设计模式的几个要素------
 * 名字：必须有一个简单，有意义的名字
 * 问题：描述在何时使用模式
 * 解决方案：描述设计的组成部分以及如何解决问题
 * 效果：描述模式的效果以及优缺点
 * 设计模式的分类------------
 * 创建型模式(6)：简单工厂模式，工厂方法模式，抽象工厂模式，建造者模式，原型模式，单例模式
 * 结构型模式(7)：外观模式，适配器模式，代理模式，装饰模式，桥接模式，组合模式，享元模式
 * 行为型模式(10)：模板方法模式，观察着模式，状态模式，职责链模式，命令模式，访问者模式，策略模式，备忘录模式，迭代器模式，解释器模式。
 */
public class ModeClass {
	public static void main(String[] args) throws Exception {
		Runtime r = Runtime.getRuntime();
		System.out.println(r);
		// r.exec("notepad");//打开了 记事本，这个 获取系统命令
		// r.exec("calc");
		// r.exec("shutdown -a");
		//r.exec("C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe http://a156e7dzzmew544.cn.hsbc/iclarity/apps/attendance/");
		Robot rb = new Robot();
		
		while(true){
		rb.mouseMove(840, 400);
		rb.delay(8000);
		rb.mousePress(InputEvent.BUTTON2_MASK );	
		rb.delay(1000);
		rb.mouseRelease(InputEvent.BUTTON2_MASK);
		rb.delay(1000*6);
		}
	}
}

/*
 * 每一个java应用程序都有一个Runtime类实例，是应用程序可以和其运行的环境相连接 可以执行一些系统的操作 class Runtime{
 * private Runtime(){} private static Runtime currentRuntime = new Runtime();
 * public static Runtime getRuntime(){ return currentRuntime; } }
 */
